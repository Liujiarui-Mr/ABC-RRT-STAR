function pFeasible = findNewPoint( mapLoad, pHeuristic, pSource, pFailed, radius, nums )
%
% function name:            findNewPoint
% function objective:       the BDRG mechanism is triggered when node experiences failed extension to generate a new feasible point  
% function input:
%   mapLoad:                map matrix
%   pHeuristic:             the heuristic point determined by the tree
%   pSource:                the node (also serving as the center of BDRG) with fialed extension 
%   pFailed:                the point failed to be generated by pSource
%   radius:                 the step size
%   nums£º                  set the number of samples in BDRG
% function output:
%   pFeasible:              the newly feasible point generated by BDRG mechanism  
%


pFeasible=[];

% compute the contact point based on the failed extension from pSource to pFailed
pContact                    = backtrackingContraction( mapLoad, pSource, pFailed );


% determine the construction radius of BDRG 
tempDist                    = computeDistance( pSource, pContact );
if ( tempDist > (0.5 * radius) )   
    
    % use the collision distance as the construction radius of BDRG 
    tempList                = zeros( nums, 3 );
    tempTheta               = 2 * pi * rand;

    for i=1:nums
        tempList(i, 1:2)    = [ pSource(1)+tempDist*cos(tempTheta), pSource(2)+tempDist*sin(tempTheta) ];
        costValue           = computeDistance( pHeuristic, tempList(i, 1:2) );
        tempList(i, 3)      = costValue;
        tempTheta           = tempTheta + (2*pi)/nums;
        %plot( tempList(i, 1), tempList(i, 2), 'Marker', 'o', 'MarkerSize', 2, 'Color', 'b', 'MarkerFaceColor', 'b' );
    end

    % select the promising candidate point based on the cost-to-go or cost-to-come value 
    pointList               = sortrows(tempList, 3);
    for i=1:size(pointList, 1)
        if( collisionCheck(mapLoad, pointList(i,1:2), pSource) )
            pFeasible       = pointList(i,1:2);
            %viscircles(pSource, tempDist, 'LineWidth', 1);
            return;
        end
    end
    
    % if all samples in BDRG lie in obstacle space, select pContact as the new point 
    pFeasible               = pContact;
   
else
    
    % use the default step size as the construction radius of BDRG to prevent the planner from being trapped
    tempList                = zeros( nums, 3 );
    tempTheta               = 2 * pi * rand;
    for i=1:nums
        tempList(i, 1:2)    = [ pSource(1)+radius*cos(tempTheta), pSource(2)+radius*sin(tempTheta) ];
        costValue           = computeDistance( pHeuristic, tempList(i, 1:2) );
        tempList(i, 3)      = costValue;
        tempTheta           = tempTheta + (2*pi)/nums;
        %plot( tempList(i, 1), tempList(i, 2), 'Marker', 'o', 'MarkerSize', 2, 'Color', 'r', 'MarkerFaceColor', 'r' );
    end
    
    pointList               = sortrows(tempList, 3);
    for i=1:size(pointList, 1)
        if( collisionCheck(mapLoad, pointList(i,1:2), pSource) )
            pFeasible       = pointList(i,1:2);
            %viscircles(pSource, tempDist, 'LineWidth', 1);
            return;
        end
    end
    
    % foreced extension if all samples in BDRG lies in obstacle spaces
    while(1)
        detaTheta          = 2*pi*rand();
        randomTheta        = detaTheta + atan2( pSource(2)-pFailed(2), pSource(1)-pFailed(1) );
        pFeasible          = pSource + ( 0.5 * radius ) * [cos(randomTheta), sin(randomTheta)];
        if ( collisionCheck(mapLoad, pFeasible, pSource) )
            break;
        end
    end
    
end








end